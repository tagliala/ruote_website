<!DOCTYPE html>
<html><head>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<title>ruote - implementing participants</title>
<script src='/js/shCore.js'></script>
<script src='/js/shBrushXml.js'></script>
<script src='/js/shBrushBash.js'></script>
<script src='/js/shBrushRuby.js'></script>
<script src='/js/shBrushJScript.js'></script>
<!-- %script{ :src => "/js/jquery-1.6.1.min.js" } -->
<script src='https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js'></script>
<link href='/css/reset.css' rel='stylesheet' type='text/css'>
<link href='/css/shCore.css' rel='stylesheet' type='text/css'>
<link href='/css/shThemeRuote.css' rel='stylesheet' type='text/css'>
<link href='/css/ruote.css' rel='stylesheet' type='text/css'>
</head><body>
<div id='container'>
<div id='header'>
<div id='header-center'>
<div id='header-left'>
<a href='/'>
<img src='/images/ruote.png'>
</a>
<div id='header-subtitle'>
a ruby workflow engine
</div>
</div>
<div id='header-right'>
<div id='nav'>
<span>
<a href='/documentation.html' title='documentation'>
doc
</a>
<a href='/source.html' title='source code'>
source
</a>
<a href='/download.html' title='download'>
download
</a>
<a class='nihongo' href='/ja.html' title='日本語'>
日本語
</a>
</span>
</div>
</div>
</div>
</div>
<div id='content'>
<div id='content-center'>
<div id='sidebar'><h3 onclick='document.location = &quot;/documentation.html&quot;' style='cursor: pointer'>
Documentation
</h3>
<ul>
<li>
<a href='/ruote_website/exp/add_branches.html'>
add_branches expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/add_branches.html'>
add_branches
</a>
</li>
<li>
<a href='/ruote_website/exp/add_branches.html'>
add_branch
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/apply.html'>
apply expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/apply.html'>
apply
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/await.html'>
await expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/await.html'>
await
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/block_participant.html'>
block_participant
</a>
</li>
<li>
<a href='/ruote_website/exp/cancel_process.html'>
cancel_process expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/cancel_process.html'>
cancel_process
</a>
</li>
<li>
<a href='/ruote_website/exp/cancel_process.html'>
terminate
</a>
</li>
<li>
<a href='/ruote_website/exp/cancel_process.html'>
kill_process
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/code_participant.html'>
code_participant
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
command expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/command.html'>
skip
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
back
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
jump
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
rewind
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
continue
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
break
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
stop
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
over
</a>
</li>
<li>
<a href='/ruote_website/exp/command.html'>
reset
</a>
</li>
</ul>
<li>
<a href='/ruote_website/common_attributes.html'>
common attributes
</a>
</li>
<li>
<a href='/ruote_website/exp/concurrence.html'>
concurrence expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/concurrence.html'>
concurrence
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/concurrent_iterator.html'>
concurrent_iterator expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/concurrent_iterator.html'>
concurrent_iterator
</a>
</li>
<li>
<a href='/ruote_website/exp/concurrent_iterator.html'>
citerator
</a>
</li>
</ul>
<li>
<a href='/ruote_website/conditions.html'>
conditions
</a>
</li>
<li>
<a href='/ruote_website/configuration.html'>
configuration
</a>
</li>
<li>
<a href='/ruote_website/exp/cron.html'>
cron expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/cron.html'>
cron
</a>
</li>
<li>
<a href='/ruote_website/exp/cron.html'>
every
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/cursor.html'>
cursor expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/cursor.html'>
cursor
</a>
</li>
<li>
<a href='/ruote_website/exp/cursor.html'>
loop
</a>
</li>
<li>
<a href='/ruote_website/exp/cursor.html'>
repeat
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/decision_participant.html'>
decision_participant
</a>
</li>
<li>
<a href='/ruote_website/exp/define.html'>
define expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/define.html'>
define
</a>
</li>
<li>
<a href='/ruote_website/exp/define.html'>
process_definition
</a>
</li>
<li>
<a href='/ruote_website/exp/define.html'>
workflow_definition
</a>
</li>
</ul>
<li>
<a href='/ruote_website/documentation.html'>
documentation
</a>
</li>
<li>
<a href='/ruote_website/dollar.html'>
dollar notation
</a>
</li>
<li>
<a href='/ruote_website/download.html'>
download
</a>
</li>
<li>
<a href='/ruote_website/exp/echo.html'>
echo expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/echo.html'>
echo
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/engine_participant.html'>
engine_participant
</a>
</li>
<li>
<a href='/ruote_website/exp/equals.html'>
equals expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/equals.html'>
equals
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/error.html'>
error expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/error.html'>
error
</a>
</li>
</ul>
<li>
<a href='/ruote_website/expressions.html'>
expressions
</a>
</li>
<li>
<a href='/ruote_website/exp/filter.html'>
filter expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/filter.html'>
filter
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/forget.html'>
forget expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/forget.html'>
forget
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/given.html'>
given expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/given.html'>
given
</a>
</li>
</ul>
<li>
<a href='/ruote_website/glossary.html'>
glossary
</a>
</li>
<li>
<a href='/ruote_website/exp/if.html'>
if expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/if.html'>
if
</a>
</li>
</ul>
<li>
<a href='/ruote_website/implementing_a_storage.html'>
implementing a storage
</a>
</li>
<li class='current'>
<a href='/ruote_website/implementing_participants.html'>
implementing participants
</a>
</li>
<li>
<a href='/ruote_website/exp/inc.html'>
inc expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/inc.html'>
inc
</a>
</li>
<li>
<a href='/ruote_website/exp/inc.html'>
dec
</a>
</li>
<li>
<a href='/ruote_website/exp/inc.html'>
increment
</a>
</li>
<li>
<a href='/ruote_website/exp/inc.html'>
decrement
</a>
</li>
<li>
<a href='/ruote_website/exp/inc.html'>
push
</a>
</li>
<li>
<a href='/ruote_website/exp/inc.html'>
pop
</a>
</li>
</ul>
<li>
<a href='/ruote_website.html'>
index
</a>
</li>
<li>
<a href='/ruote_website/exp/iterator.html'>
iterator expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/iterator.html'>
iterator
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/let.html'>
let expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/let.html'>
let
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/listen.html'>
listen expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/listen.html'>
listen
</a>
</li>
<li>
<a href='/ruote_website/exp/listen.html'>
receive
</a>
</li>
<li>
<a href='/ruote_website/exp/listen.html'>
intercept
</a>
</li>
</ul>
<li>
<a href='/ruote_website/lists.html'>
lists
</a>
</li>
<li>
<a href='/ruote_website/part/local_participant.html'>
local_participant
</a>
</li>
<li>
<a href='/ruote_website/exp/lose.html'>
lose expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/lose.html'>
lose
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/no_op_participant.html'>
no_op_participant
</a>
</li>
<li>
<a href='/ruote_website/noisy.html'>
noisy output
</a>
</li>
<li>
<a href='/ruote_website/exp/noop.html'>
noop expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/noop.html'>
noop
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/null_participant.html'>
null_participant
</a>
</li>
<li>
<a href='/ruote_website/exp/on_error.html'>
on_error expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/on_error.html'>
on_error
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/once.html'>
once expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/once.html'>
once
</a>
</li>
<li>
<a href='/ruote_website/exp/once.html'>
when
</a>
</li>
<li>
<a href='/ruote_website/exp/once.html'>
as_soon_as
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/participant.html'>
participant expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/participant.html'>
participant
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part_implementations.html'>
participant implementations
</a>
</li>
<li>
<a href='/ruote_website/presentations.html'>
presentations
</a>
</li>
<li>
<a href='/ruote_website/process_administration.html'>
process administration
</a>
</li>
<li>
<a href='/ruote_website/definitions.html'>
process definitions
</a>
</li>
<li>
<a href='/ruote_website/process_observation.html'>
process observation
</a>
</li>
<li>
<a href='/ruote_website/participants.html'>
process participants
</a>
</li>
<li>
<a href='/ruote_website/exp/read.html'>
read expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/read.html'>
read
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/redo.html'>
redo expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/redo.html'>
redo
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/ref.html'>
ref expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/ref.html'>
ref
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/registerp.html'>
registerp expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/registerp.html'>
registerp
</a>
</li>
</ul>
<li>
<a href='/ruote_website/rel.html'>
rel values for ruote-http / ruote-kit links
</a>
</li>
<li>
<a href='/ruote_website/exp/reserve.html'>
reserve expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/reserve.html'>
reserve
</a>
</li>
</ul>
<li>
<a href='/ruote_website/resources.html'>
resources
</a>
</li>
<li>
<a href='/ruote_website/exp/restore.html'>
restore expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/restore.html'>
restore
</a>
</li>
<li>
<a href='/ruote_website/exp/restore.html'>
set_fields
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/rev_participant.html'>
rev_participant
</a>
</li>
<li>
<a href='/ruote_website/users.html'>
ruote users
</a>
</li>
<li>
<a href='/ruote_website/sample_workflow_run.html'>
sample workflow run
</a>
</li>
<li>
<a href='/ruote_website/exp/save.html'>
save expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/save.html'>
save
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/sequence.html'>
sequence expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/sequence.html'>
sequence
</a>
</li>
<li>
<a href='/ruote_website/exp/sequence.html'>
let
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/set.html'>
set expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/set.html'>
rset
</a>
</li>
<li>
<a href='/ruote_website/exp/set.html'>
set
</a>
</li>
<li>
<a href='/ruote_website/exp/set.html'>
unset
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/smtp_participant.html'>
smtp_participant
</a>
</li>
<li>
<a href='/ruote_website/source.html'>
source
</a>
</li>
<li>
<a href='/ruote_website/exp/stall.html'>
stall expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/stall.html'>
stall
</a>
</li>
</ul>
<li>
<a href='/ruote_website/part/storage_participant.html'>
storage_participant
</a>
</li>
<li>
<a href='/ruote_website/exp/subprocess.html'>
subprocess expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/subprocess.html'>
subprocess
</a>
</li>
</ul>
<li>
<a href='/ruote_website/testing_participants.html'>
testing participants
</a>
</li>
<li>
<a href='/ruote_website/testing_processes.html'>
testing processes
</a>
</li>
<li>
<a href='/ruote_website/exp/that.html'>
that expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/that.html'>
that
</a>
</li>
<li>
<a href='/ruote_website/exp/that.html'>
of
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/undo.html'>
undo expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/undo.html'>
undo
</a>
</li>
<li>
<a href='/ruote_website/exp/undo.html'>
cancel
</a>
</li>
<li>
<a href='/ruote_website/exp/undo.html'>
kill
</a>
</li>
</ul>
<li>
<a href='/ruote_website/exp/unregisterp.html'>
unregisterp expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/unregisterp.html'>
unregisterp
</a>
</li>
</ul>
<li>
<a href='/ruote_website/vars_and_fields.html'>
variables and fields
</a>
</li>
<li>
<a href='/ruote_website/exp/wait.html'>
wait expression
</a>
</li>
<ul class='alias'>
<li>
<a href='/ruote_website/exp/wait.html'>
wait
</a>
</li>
<li>
<a href='/ruote_website/exp/wait.html'>
sleep
</a>
</li>
</ul>
<li>
<a href='/ruote_website/with_rails.html'>
with rails
</a>
</li>
<li>
<a href='/ruote_website/patterns.html'>
workflow control patterns
</a>
</li>
<li>
<a href='/ruote_website/ja.html'>
日本語
</a>
</li>
</ul>
<h3>
More
</h3>
<ul class='contact'>
<li>
<a href='https://github.com/jmettraux/ruote/tree/master/quickstart'>
quickstart
</a>
</li>
<li>
<a href='/presentations.html'>
presentations
</a>
</li>
<li>
<a href='/resources.html'>
resources
</a>
</li>
<li>
<a href='/users.html'>
users
</a>
</li>
</ul>
<h3>
Meta
</h3>
<ul class='contact'>
<li>
<a href='/source.html'>
source
</a>
</li>
<li>
<a href='/download.html'>
download
</a>
</li>
<li>
<a href='http://jmettraux.github.com'>
blog
</a>
</li>
<li>
<a href='/lists.html'>
mailing list
</a>
</li>
<li>
<a href='http://ruote-ci.s3.amazonaws.com/ci.html'>
continuous integration
</a>
</li>
<li>
<a href='http://ruote-irclogs.s3.amazonaws.com/logs.html'>
IRC
</a>
</li>
<li>
<a href='https://www.ohloh.net/p/ruote/'>
on ohloh
</a>
</li>
</ul>
<h3>
<span>
Search
</span>
</h3>
<ul class='contact'>
<li>
<form action='http://www.google.com/search' method='GET'>
<input id='qq' name='qq' style='' type='text'>
<input id='q' name='q' type='hidden'>
<input onclick='adjustSearch();' type='submit' value='search'>
</form>
</li>
</ul>
<script>
  function adjustSearch() {
    $('#q').val($('#qq').val() + ' site:http://ruote.rubyforge.org');
  }
</script>
</div>
<div id='content-main'>
<h2>implementing participants</h2>
<p>Participant receive workitems, do something about/to them. Then, if necessary, they reply to ruote with the [updated] workitem.</p>
<p>In its simplest form a participant implementation will take the form of a <a href="/part/block_participant.html">block participant</a>.</p>
<pre class="brush: ruby">
engine.register_participant :flush_garbage do |workitem|
  GarbageCan.find(workitem.fields['garbage_can_id']).flush
end
</pre>
<p>In fact, this is equivalent to the following participant implementation (and registration) :</p>
<pre class="brush: ruby">
class Flusher
  include Ruote::LocalParticipant

  def on_workitem
    GarbageCan.find(workitem.fields['garbage_can_id']).flush
    reply
  end

  def on_cancel
    # nothing to do
  end

  #def on_reply
  #end
end

engine.register_participant :flush_garbage, Flusher
</pre>
<p>Yes, you are right, the block participant&#8217;s block is reproduced in the on_workitem method of the participant implementation, but a reply is added.</p>
<p><a href="#on_workitem">#on_workitem</a> isn&#8217;t the only method involved in a participant, there is also <a href="#on_cancel">#on_cancel</a>. Cancel is called when a process instance or a segment of it gets cancelled and the participant holds a workitem for the segment. The workitem has to be somehow cancelled / removed / rolled back.</p>
<p>Two optional methods also exist : <a href="#accept">#accept?</a> and <a href="#on_reply">#on_reply</a>. A participant with an accept? method is free to discard incoming workitems that it doesn&#8217;t like. A participant with an on_reply method is usually some kind of proxy for a real (remote) participant; the on_reply method, when present, is called when the answer (workitem) comes back from the real participant.</p>
<p>By default, when a process instance execution reaches a participant expression, it runs the #on_workitem method of the participant in a dedicated Ruby thread. if the <a href="#do_not_thread">#do_not_thread</a> method returns false, no extra thread is created, the #on_workitem call is done immediately (ie, it blocks the worker).</p>
<h3 id="participant">Ruote::Participant (class)</h3>
<p>Ruote 2.3.0 brings a new Ruote::Participant class which includes the Ruote::LocalParticipant module and brings an empty implementation of on_cancel. Thus the above participant can be written:</p>
<pre class="brush: ruby">
class Flusher &lt; Ruote::Participant

  def on_workitem
    GarbageCan.find(workitem.fields['garbage_can_id']).flush
    reply
  end
end
</pre>
<h3 id="local_participant">Ruote::LocalParticipant (module)</h3>
<p>Most of the time, you&#8217;ll want your participant to include the Ruote::LocalParticipant mixin.</p>
<p>It&#8217;s named &#8216;local&#8217; because it has access to the ruote storage.</p>
<hr />
<p>Methods to implement or override when implementing a participant and some helpers granted by Ruote::LocalParticipant.</p>
<h3>methods</h3>
<ul>
	<li><a href="#on_workitem">#on_workitem</a> (was &#8220;consume&#8221; before 2.3.0)</li>
	<li><a href="#on_cancel">#on_cancel</a> (was &#8220;cancel&#8221; before 2.3.0)</li>
	<li><a href="#accept">#accept?</a></li>
	<li><a href="#on_apply">#on_apply</a></li>
	<li><a href="#on_reply">#on_reply</a></li>
	<li><a href="#do_not_thread">#do_not_thread</a> (<a href="#dont_thread">#dont_thread?</a>)</li>
</ul>
<ul>
	<li><a href="#re_dispatch">#re_dispatch</a></li>
	<li><a href="#unschedule_re_dispatch">#unschedule_re_dispatch</a></li>
</ul>
<ul>
	<li><a href="#rtimeout">#rtimeout</a></li>
	<li><a href="#rtimers">#rtimers</a></li>
</ul>
<h3>helpers</h3>
<ul>
	<li><a href="#reply_to_engine">reply_to_engine</a> (<a href="#reply">reply</a>)</li>
	<li><a href="#fexp">fexp</a></li>
	<li><a href="#workitem">workitem</a></li>
	<li><a href="#applied_workitem">applied_workitem</a></li>
	<li><a href="#participant_name">participant_name</a></li>
	<li><a href="#lookup_variable">lookup_variable</a></li>
	<li><a href="#stash">put and get</a></li>
</ul>
<hr />
<h3 id="on_workitem">#on_workitem</h3>
<p>When a participant is handed a workitem, this method is called with the workitem as the argument.</p>
<pre class="brush: ruby">
# computing the total for a invoice being passed in the workitem.
#
class TotalParticipant
  include Ruote::LocalParticipant

  def on_workitem
    workitem.fields['total'] =
      workitem.fields['items'].inject(0.0) { |t, item|
        t + item['count'] * PricingService.lookup(item['id'])
      }
    reply
  end
end
</pre>
<p>Note the call to #reply when the work is done. Without this call (sooner or later), the process doesn&#8217;t resume after this participant.</p>
<h3 id="on_cancel">#on_cancel</h3>
<p>If you don&#8217;t immediately (and very quickly) reply to the engine in your #on_workitem method, you&#8217;d better have a #on_cancel implementation for your class.</p>
<pre class="brush: ruby">
require 'fileutils'
require 'yaml'

# A plain "worklist" implementations, workitems are placed in files under
# worklist/
#
# We assume the rest of the application reads those yaml files and
# calls PlainWorklist.reply(workitem_h) when done with a workitem.
#
class PlainWorklist
  include Ruote::LocalParticipant

  # Called by ruote when there's work for our participant
  #
  def on_workitem
    h = workitem.to_h
    h['fei'] = workitem.fei.sid
    File.open("worklist/workitem_#{workitem.fei.sid}.yaml", wb) do |f|
      f.puts(h.to_yaml)
    end
    # no reply_to_engine
  end

  # When ruote has to cancel a process instance with an active workitem
  # for this participant, this method is called.
  #
  def on_cancel
    puts "(cancelling, flavour is #{flavour}"
    FileUtils.rm("worklist/workitem_#{fei.sid}.yaml")
  end

  # A method called by external systems when they're done with a workitem
  # hash, they hand it back to the engine via this method.
  #
  def self.reply(workitem_h)
    FileUtils.rm("worklist/workitem_#{workitem_h['fei']}.yaml")
    receive(workitem)
  end
end
</pre>
<p>Our on_workitem method doesn&#8217;t reply to the engine, at all. The reply occurs later, in the #reply class method. If a cancel order comes, the workitem stored on disk has to be removed.</p>
<p>When #on_cancel returns false, no reply will be emitted towards ruote. It can be useful in scenarii where the #on_workitem itself deals with cancel messages (and it has some way to know about them&#8230;).</p>
<h4 id="flavour">cancel flavour</h4>
<p>This parameter is usually set to &#8216;cancel&#8217;. When a process is <a href="/process_administration.html#killing">killed instead of cancelled</a>, the flavour is set to &#8220;kill&#8221;. Usually this parameter is simply ignored, but who knows, perhaps a different behaviour might be necessary in some context?</p>
<h3 id="accept">#accept?</h3>
<p>Given a list of participant</p>
<pre class="brush: ruby">
engine.register_participant 'al.+', FirstParticipantImplementation
engine.register_participant 'al.+', SecondParticipantImplementation
</pre>
<p>the first participant whose regex matches the participant name is used. If that first participant has a method #accept?(workitem), it&#8217;s called and if it replies with false, the next participant in the participant list is tried.</p>
<pre class="brush: ruby">
class FirstParticipantImplementation
  include Ruote::LocalParticipant

  # Do something...
  #
  def on_workitem
    workitem.fields['message'] = 'kilroy was here'
    reply
  end

  # This participant will not accept workitems for non military contexts.
  # The next matching participant in the participant list will be consulted.
  #
  def accept?
    workitem.fields['context'] == 'military'
  end
end
</pre>
<h3 id="on_apply">#on_apply</h3>
<p>Equivalent to <a href="#on_reply">on_reply</a>, but triggers before the workitem is dispatched to the participant. It gives participant implementers an opportunity to perform some operations before the dispatch. The typical example is adding some information to the workitem before it&#8217;s passed on.</p>
<p>Note, that like for &#8216;on_reply&#8217;:#on_reply, on_apply is executed in the worker thread (whereas dispatch is performed, by default, in a new thread).</p>
<h3 id="on_reply">#on_reply</h3>
<p>Roughly, there are two categories of participants, those who receive a workitem and reply immediately and those who take some time before replying.</p>
<p>In this second category, one can find participants that emit workitem to a remote participant. The workitem comes back via a listener usually.</p>
<p>Participants that provide a #on_reply(workitem) implementation are given a opportunity to tweak the workitem once it comes back.</p>
<p>Here is an example where an hypothetical WorkQueue is placed between the ruote system and the remote participant bound under the name &#8220;remote&#8221;. The receiver pops messages and feeds the back to the engine. When workitems come back, the worker will hand it to the on_reply method of the participant.</p>
<pre class="brush: ruby">
class MyRemoteParticipant
  #include Ruote::LocalParticipant

  def on_workitem
    WorkQueue.push(workitem_to_msg(workitem))
  end

  def on_reply
    workitem.fields['msg'] = "back at #{Time.now.to_s}"
  end

  protected

  def workitem_to_msg(workitem)
    # ...
  end
end

class Receiver &lt; Ruote::Receiver

  def initialize(engine)
    super
    Thread.new { listen }
  end

  protected

  def listen
    loop { reply_to_engine(workitem_from_msg(WorkQueue.pop)) }
  end

  def workitem_from_msg(msg)
    # ...
  end
end

engine = Ruote::Engine.new(Ruote::Worker.new(Ruote::HashStorage.new))

engine.register_participant :remote, MyRemoteParticipant

receiver = Receiver.new(engine)

# ...
</pre>
<h3 id="do_not_thread">#do_not_thread #dont_thread? <a name="dont_thread"> </a></h3>
<p>By default, when dispatching a workitem to a participant, a ruote worker will call the participant&#8217;s #on_workitem method in a new thread. The idea is to move the [potentially] bulk work of dispatching outside of the worker loop very quickly.</p>
<p>This is not always appropriate. The participant can tell the worker not to spawn a new thread by implementing a do_not_thread method and letting it reply with true when it&#8217;s called.</p>
<pre class="brush: ruby">
class MyParticipant
  include Ruote::LocalParticipant

  # Do something...
  #
  def on_workitem
    workitem.fields['message'] = 'kilroy was here'
    reply
  end

  # The #on_workitem method does such a trivial thing that it's not worth spawning
  # a thread.
  #
  def do_not_thread
    true
  end
end
</pre>
<p>It&#8217;s OK to have a do_not_thread method that accepts the workitem as argument :</p>
<pre class="brush: ruby">
  def do_not_thread
    workitem.fields['colour'] == 'blue'
  end
</pre>
<p>If you want to influence more radically threading while dispatching, overriding the dispatch_pool service is probably the best solution.</p>
<pre class="brush: ruby">
#
# This implementation never dispatches in a new thread...
#
class MyDispatchPool &lt; Ruote::DispatchPool

  def dispatch(msg)

    participant = @context.plist.lookup(
      msg['participant'] || msg['participant_name'], msg['workitem'])

    do_dispatch(participant, msg)
  end
end

# ...

opts = {
  's_dispatch_pool' =&gt; [ 'path/to/my_dispatch_pool', 'MyDispatchPool' ]
}

engine = Ruote::Engine.new(Ruote::Worker.new(Ruote::HashStorage.new(opts)))
</pre>
<p>or something like that&#8230;</p>
<p>From ruote 2.3.0 on, you can use the dont_thread? method instead, and the workitem is implicit (like from #on_workitem and #on_reply). So this is OK :</p>
<pre class="brush: ruby">
  def dont_thread?
    workitem.fields['colour'] == 'blue'
  end
</pre>
<h3 id="re_dispatch">#re_dispatch</h3>
<p>Use this method to re_dispatch the workitem.</p>
<p>It takes two options :in and :at for &#8220;later re_dispatch&#8221;. Without one of those options, the method is a &#8220;reject&#8221;.</p>
<p>Here is an example where re_dispatch is used to implement a retry tactic.</p>
<pre class="brush: ruby">
class RetryParticipant
  include Ruote::LocalParticipant

  def initialize(opts)
    @opts = opts
  end

  def on_workitem
    begin
      do_the_job
      reply
    rescue
      re_dispatch(workitem, :in =&gt; @opts['delay'] || '1s')
    end
  end

  def on_cancel
    # fei is set for the participant and contains the "FlowExpressionId" of
    # the expression getting cancelled
    unschedule_re_dispatch(fei)
  end
end
</pre>
<p>re_dispatch/reject makes sense too in a multi worker context where a participant on a given host wants to reject a task and let another worker (on another host) do the work. Maybe the <a href="#accept">accept?</a> method is better for those cases, though.</p>
<h3 id="unschedule_re_dispatch">#unschedule_re_dispatch</h3>
<p>Look at the example in the <a href="#re_dispatch">previous section</a> to see unschedule_re_dispatch in action.</p>
<h3 id="rtimeout">#rtimeout</h3>
<p>Usually, timeouts are given for an expression in the process definition.</p>
<pre class="brush: ruby">
participant 'alice', :timeout =&gt; '2d'
</pre>
<p>where alice as two days to complete her task (send back the workitem).</p>
<p>But it&#8217;s OK for participant classes registered in the engine to provide<br />
their own timeout value. The participant instance simply has to reply to<br />
the #rtimeout method and provide a meaningful timeout value (like a<br />
number of seconds, or a string like &#8220;2d&#8221; or &#8220;1M2w&#8221;. For example :</p>
<pre class="brush: ruby">
class MyParticipant
  # ...
  def rtimeout(workitem)
    workitem.fields['category'] == 'shoes' ? '2w' : '1w'
  end
  # ...
end
</pre>
<p>From ruote 2.3.0 on, the workitem is implicit :</p>
<pre class="brush: ruby">
class MyParticipant
  # ...
  def rtimeout
    workitem.fields['category'] == 'shoes' ? '2w' : '1w'
  end
  # ...
end
</pre>
<p>Note however, that the process definition timeout (if any) will take<br />
precedence over the participant specified one.</p>
<h3 id="rtimers">#rtimers</h3>
<p>We saw above that #rtimeout can provide a default value for a participant<br />
&#8220;timeout&#8221; attribute. Likewise, #rtimers provides a default value for the<br />
&#8220;timers&#8221; attribute.</p>
<pre class="brush: ruby">
class MyParticipant
  # ...
  def rtimeout
    '1h: reminder, 12h: error'
  end
  # ...
end
</pre>
<p>For more info about the <a href="/common_attributes.html#timers">timers</a> common attribute.</p>
<hr />
<h3 id="reply">reply</h3>
<p>Often used at the end of a on_workitem implementation.</p>
<pre class="brush: ruby">
class Total
  include Ruote::LocalParticipant

  def on_workitem
    workitem.fields['total'] =
      workitem.fields['items'].inject(0) { |t, (i, c)|
        item = Item.find(i)
        t = t + c * item.price
      }
    reply
  end
end

engine.register 'total', Total
</pre>
<p>If you scroll a bit, you&#8217;ll find <a href="#applied_workitem">an example</a> where this method is called outside of the #on_workitem method.</p>
<h3 id="fexp">fexp</h3>
<p>Via this method, the participant implementation has access to its [participant] expression.</p>
<pre class="brush: ruby">
class PickCustomer
  include Ruote::LocalParticipant

  def on_workitem
    customers = fexp.lookup_variable('customers')
    workitem.fields['customer'] = customers[rand(customers.length)]
    reply
  end
end

engine.register 'pick_customer', PickCustomer
</pre>
<h3 id="workitem">workitem</h3>
<p>Whereas applied_workitem returns the workitem as was applied (to the participant expression), workitem returns the workitem as was dispatched to this participant [implementation].</p>
<p>The main difference is that a workitem as dispatched contains the &#8216;params&#8217; field corresponding to the attributes specified in the process definition.</p>
<h3 id="applied_workitem">applied_workitem</h3>
<p>Especially when a participant is meant as a task list, workitems may get modified and not immediately replied (proceeded) to the engine.</p>
<p>It could be necessary to look at a copy of the workitem as it was when it reached the participant [expression].</p>
<pre class="brush: ruby">
class TaskList
  include Ruote::LocalParticipant

  def initialize(opts)
    @tasks = connect_to_some_db(opts)
  end

  def on_workitem
    @tasks[workitem.fei] = workitem
  end

  def on_cancel
    @tasks.delete(fei)
  end

  def by_user(username)
    @tasks.by(:user =&gt; username)
  end

  def update(workitem)
    @tasks[workitem.fei] = workitem
  end

  def original(workitem)
    applied_workitem(workitem)
  end

  def self.reply(workitem)
    if @tasks.delete[workitem.fei]
      reply_to_engine(workitem)
    end
  end
end

# ...

engine.register 'user_.+', TaskList

# ...

tasklist = engine.participant('user_x')
  # returns an instance of our participant, 'user_x' will do since
  # it's registered for any participant starting with 'user_'

workitem = tasklist.by_user('user_fred').first

if workitem.fields != tasklist.original(workitem).fields
  puts "fred's workitem got modified"
end

tasklist.reply(workitem)
</pre>
<p>Note the use of Engine#participant(name) to fetch an instance of a participant via the engine.</p>
<h3 id="participant_name">participant_name</h3>
<p>Since ruote 2.3.0, it&#8217;s ok to shorten</p>
<pre class="brush: ruby">
def consume(workitem)
  (workitem.fields['supervisors'] ||= []) &lt;&lt; workitem.participant_name
  reply_to_engine(workitem)
end
</pre>
<p>to</p>
<pre class="brush: ruby">
def on_workitem
  (workitem.fields['supervisors'] ||= []) &lt;&lt; participant_name
  reply
end
</pre>
<p>(the simplification to notice here is the one from &#8220;workitem.participant_name&#8221; to &#8220;participant_name&#8221;, well it&#8217;s not the only simplification&#8230;)</p>
<h3 id="lookup_variable">lookup_variable</h3>
<p>Quickly do a variable lookup in the participant expression.</p>
<pre class="brush: ruby">
def on_workitem
  workitem.fields['my_var'] = lookup_variable('my_var')
  workitem.fields['my_other_var'] = fexp.lookup_variable('my_other_var')
  reply
end
</pre>
<h3 id="stash">put and get</h3>
<p>Sometimes participant implementations need to stash data somewhere, but they can&#8217;t do it in the workitem itself (visibility issues). There are the <em>put</em> and <em>get</em> methods available.</p>
<p>You&#8217;ll find an example at the end of this <a href="http://groups.google.com/group/openwferu-users/browse_thread/thread/2e6a95708c10847b">discussion thread</a>.</p>
</div>
</div>
</div>
</div>
<div id='footer'>
<div id='footer-center'>
<p>
<span id='footer-left'>
<a href='https://github.com/jmettraux/ruote_website/issues'>doc issue reporting</a>
|
<a href='https://github.com/jmettraux/ruote_website'>doc source</a>
| created with
<a href='http://nanoc.stoneship.org'>nanoc</a>
and
<a href='http://alexgorbatchev.com/SyntaxHighlighter/'>syntax highlighter</a>
</span>
<span id='footer-right'>
&copy; 2005-2013 the ruote team
</span>
</p>
</div>
</div>
<script>
  SyntaxHighlighter.all();
  
  if (location.hostname != 'localhost' && location.hostname != '127.0.0.1') {
  
    // gauges
  
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '50454d13f5a1f57e4200001b');
      t.src = '//secure.gaug.es/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  
    // ga
  
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-138748-2']);
    _gaq.push(['_trackPageview']);
  
    (function() {
      var ga = document.createElement('script');
      ga.type = 'text/javascript';
      ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(ga, s);
    })();
  }
</script>
</body>
</html>
